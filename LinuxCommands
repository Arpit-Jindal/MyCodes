cd - For changing directory.
ls - For listing files.
	 ls -a ==> for all files including hidden.
	 ls -R ==> for subdirectories as well.
	 ls -l ==> for showing permissions of files of directory.
rm - For removing files.
mv - For moving as well as removing files.
	 mv file1 file2 ==> renames file1 to file2
	 mv ./file1 /home/user/Desktop ==> For moving file from present directory to Desktop	
mkdir - Creating new directory.
rmdir - For removing directories.
cat - For creating text files.
	  cat > file_name ==> for creating file_name.txt
	  cat file_name ==> to open file_name
	  cat file1 file2 > file 3 ==> Creates file3 with file1 and file2 contents
	  cat file | grep string ==> higlights that portion with string


man - Stands for manual. eg. man mkdir
history - History of all the commands that you have entered in terminal.
pwd - Present working directory

finger - For details of logged in users.


top 
ps ux
ps <pid>
pidof <process> ==> eg : pidof vlc
kill <pid>
free ==> Shows ram usage. free -m ==>Shows in MBs | free -g ==>SHows in GBs
df ==> Drive Usage


----------------------------------------------------------------------------
Evrything in linux acts as files be it devices like printers, hdds, pendrive etc. Directories are also files. Linux is case sensitive. '.' means current directory and '..' means parent directory. Hidden files and directories starts with '.' period.
-----------------------------------------------------------------------------
Linux has two levels of authorization : PERMISSIONS and OWNERSHIP
OWNERSHIP - USER
			GROUP
			OTHERS (Users that are not in group)
PERMISSION - READ(r)
			 WRITE(w)
			 EXECUTE(e)
 We use ls -l to print all the permissions associated with files in that directory.
 Eg : d rwx rwx rwx
 	  -	--- --- ---
 	  0 123 456 789
 	  0==> 'd' if directory, '-' if file
 	  123==> for user
 	  456==> for group
 	  789==> for other
 	  r/w/x for read/write/execute, '-' for no permission
Command for changing permissions ==> chmod permissions file_name
We can change permissions using two different modes : ABSOLUTE MODE and SYMBOLIC MODE

ABSOLUTE MODE uses codes : 
Number	Permission Type			Symbol
0		No Permission			---
1		Execute					--x
2		Write					-w-
3		Execute + Write			-wx
4		Read					r--
5		Read + Execute			r-x
6		Read +Write				rw-
7		Read + Write +Execute	rwx
Eg chmod 764 file_name ==> sets permissions 7 for user, 6 for group, 4 for others.
Read = 4/ Write = 2/ Execute = 1


SYMBOLIC MODE can change individual permissions for owners.
Eg: chmod u=rwx file_name ==> changes user permission to read write and execute.
	chmod g+x file_name ==> adds executable permission to group.
	chmod o-w file_name ==> removes write permission from others.
To change the owner of a file we use command : chown user file_name ==> to change owner of a file.
											   chown root:root file_name ==> to change owner as well as group.
											   chgrp root file_name ==> to change group only.
											   NOTE :: Make sure we use this commands as super user, SUDO.
-----------------------------------------------------------------------------------------------------
To use terminal as root, type : sudo -i
-----------------------------------------------------------------------------------------------------
Output redirection : ls -l / > File ==> saves terminal output to File
					 echo Hello >> File ==> appends Hello to already existing File.
-----------------------------------------------------------------------------------------------------
vi text editor : Two modes, Command mode and insert mode. Insert mode by typing 'i'. Command mode by pressing ESC. Command mode is used for navigation and deletion.
-----------------------------------------------------------------------------------------------------
Virtual terminals are CLIs which execute the user commands
There are six virtual terminals which can be launched using the shortcut keys
They offer multi-user environment and up to six users can work on them at the same time
Unlike terminals you cannot use mouse with virtual terminals
To launch a virtual terminal press Ctrl+Alt+F(1 to 6) on the keyboard
Use the same command for navigating through the different terminals
To return to the home screen of the Linux system, use Ctrl+Alt+F7 and it would take to you the terminal
------------------------------------------------------------------------------------------------------

In linux systems, most powerful is root user. To use a terminal as root user we type 'su'. su has its own password. By default its password is not declared. We can set 'su' password by typing 'sudo passwd'. After this we can login as root in terminal by typing 'su' and entering root password.
Other users, if allowed, can use sudo command. We can execute any command from any other user login by typing sudo before the command. Then user can enter his password (not root password) and execute that command as SUPERUSER (having same priveleges as root). We can also login as root by using 'sudo su' from other logins with sudo power.
------------------------------------------------------------------------------------------------------
Managing Users and Groups

adduser <nameofuser> ==> to add new user.
deluser <nameofuser> ==> to delete user account only.
deluser --remove-all-files <username> ==> deletes everything ever owned by user. --remove-home also!

------------------------------------------------------------------------------------------------------

Tar - TApe aRchiver
Source code is often packed for download as a TAR (Tape ARchive) file, that is a standard format in the Unix/Linux world. These files have a .tar extension; they can also be compressed, the extension is .tar.gz or .tar.bz2 in these cases. There are several ways to unpack these files.
No compression == Uncompressed files have the file ending .tar.
Gzip Compression == The Gzip format is the most widely used compression format for tar, it is fast for creating and extracting files. Files with gz compression have normally the file ending .tar.gz or .tgz. 
Bzip2 Compression == The Bzip2 format offers a better compression then the Gzip format. Creating files is slower, the file ending is usually .tar.bz2.

tar commands can also work without '-' before secondary arguments. Secondary arguments can also be concatenated.

c = create a new archive
x = extract file from archive
t = listing files of archive
v = verbosely list files which are processed.
f = following is the archive file name
z = filter the archive through gzip
j =	filter the archive through bzip2
Note: .tgz is same as .tar.gz
	  .tbz and .tb2 is same as .tar.bz2
Also keep cvf,tvf,xvf order same add optional arguments like z or j in the end only.

To extract a specific file from a tar archive, specify the file name at the end of the tar xvf command as shown below. The following command extracts only a specific file from a large tar file.
$ tar xvf archive_file.tar file_name_to_be_extracted

For more info on tar: http://www.thegeekstuff.com/2010/04/unix-tar-command-examples
------------------------------------------------------------------------------------------------------
Installing softwares from tar balls.
First extract the tar files.
Generally you need to type 3 commands as follows for building and compiling software:
# ./configure
# make
# make install


Where,
./configure == will configure the software to ensure your system has the necessary functionality and 	libraries to successfully compile the package.
make == will compile all the source files into executable binaries.
make install == will install the binaries and any supporting files into the appropriate locations.
Extract tar anywhere and run those commands from the extracted directory. make install will automatically put in appropriate location.
There is no rule but usually /usr/local (i.e., /usr/local/bin for binaries).
You can also specify where do you want to install with the --prefix option. For example
# ./configure --prefix /home/myuser
will install the software in your home directory.
------------------------------------------------------------------------------------------------------
In linux terminal, each command is nothing but an executable file. For eg, when we type pwd in terminal, an executable file named pwd in /bin/pwd is run. 
To know where a particular command file is stored we use 'which' command. 
$which pwd  ==> this returns the location where pwd is stored.

Compiling C++ programs in Linux.
Linux has GNU Compiler. To compile C++ program we have 
$g++ file_name.cpp -o object_file_name ==> If we dont write -o object_file_name we get a.out by default.
To run this executable file, we do
$./object_file_name 

Also to use C++11, add '-std=c++11'

In the terminal, whenever you type the name of an application, let's say gedit, the terminal will go 
look in some (pre-defined) directories that contain applications (the binaries of the applications). 
The names of these directories are contained in a variable called PATH. You can see what's in this 
variable by executing echo $PATH. See those directories separated by :? Those are the directories 
that the terminal will go search in, if you just type gedit, nautilus, or a.out. As you can see, the 
path of your a.out program is not there. When you do ./a.out, you're telling the terminal "look in 
the current directory, and run a.out, and don't go look in PATH.

